;;;; URI Parser

(defstruct uri scheme userinfo host port path query fragment)



;;;; parsing functions

(defun uri-parse (stringa)
  (let* ((lista (coerce stringa 'list))
	 (scheme (parse-to lista #\:))
	 (tail (parse-from lista #\:))
	 (scheme_s (coerce scheme 'string))
	 (my_list (append (list scheme_s) '())))
    (check-scheme scheme)
    (cond ((equal scheme_s "mailto") (parse-userinfo-mail my_list tail))
	  ((equal scheme_s "news")   (parse-host-news my_list tail))
	  ((equal scheme_s "tel")    (parse-userinfo-tel my_list tail))
	  ((equal scheme_s "fax")    (parse-userinfo-tel my_list tail))
	  ((equal scheme_s "zos")    (parse-authority my_list tail T))
	  (T (parse-authority my_list tail)))))

(defun parse-authority (lista tail &optional zos)
  (cond ((and (equal (car (cdr tail)) #\/)
	      (equal (car (cdr (cdr tail))) #\/))
	 (parse-userinfo lista (cdr (cdr (cdr tail))) zos))
	(T (let* ((my_list0 (append lista '(NIL)))
		  (my_list1 (append my_list0 '(NIL)))
		  (my_list2 (append my_list1 '(80))))
	     (parse-path my_list2 (cdr tail) zos)))))
	
(defun parse-userinfo (lista tail &optional zos)
  (cond ((not (present tail #\@))
	 (let ((my_list (append lista '(NIL)))) (parse-host my_list tail zos)))
	(T (let* ((userinfo (parse-to tail #\@))
		  (rest (parse-from tail #\@))
		  (userinfo_s (coerce userinfo 'string))
		  (my_list (append lista (list userinfo_s))))
	     (check-userinfo userinfo)
	     (parse-host my_list rest zos)))))

(defun parse-host (lista tail &optional zos)
  (cond ((equal (car tail) #\@) (parse-host lista (cdr tail) zos))
	((present tail #\:)
	 (let* ((host (parse-to tail #\:))
		(rest (parse-from tail #\:))
		(host_s (coerce host 'string))
		(my_list (append lista (list host_s))))
	   (check-host host)
	   (parse-port my_list (cdr rest) zos)))
	((present tail #\/)
	 (let* ((host (parse-to tail #\/))
		(rest (parse-from tail #\/))
		(host_s (coerce host 'string))
		(my_list0 (append lista (list host_s)))
		(my_list1 (append my_list0 '(80))))
	   (check-host host)
	   (parse-path my_list1 rest zos)))
	((present tail #\?)
	 (let* ((host (parse-to tail #\?))
		(rest (parse-from tail #\?))
		(host_s (coerce host 'string))
		(my_list0 (append lista (list host_s)))
		(my_list1 (append my_list0 '(80)))
		(my_list2 (append my_list1 '(NIL))))
	   (check-host host)
	   (parse-query my_list2 (cdr rest))))
	((present tail #\#)
	 (let* ((host (parse-to tail #\#))
		(rest (parse-from tail #\#))
		(host_s (coerce host 'string))
		(my_list0 (append lista (list host_s)))
		(my_list1 (append my_list0 '(80)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL))))
	   (check-host host)
	   (parse-fragment my_list3 (cdr rest))))
	(T
	 (let* ((host_s (coerce tail 'string))
		(my_list0 (append lista (list host_s)))
		(my_list1 (append my_list0 '(80)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL))))
	   (check-host tail)
	   (all-for-one my_list4)))))

(defun parse-port (lista tail &optional zos)
  (cond ((present tail #\/)
	 (let* ((port (parse-to tail #\/))      
		(rest (parse-from tail #\/))
		(port_s (coerce port 'string))
		(temp (check-port port))
		(port_i (parse-integer port_s))
		(my_list (append lista (list port_i))))
	   (parse-path my_list rest zos)))
	((present tail #\?)
	 (let* ((port (parse-to tail #\?))      
		(rest (parse-from tail #\?))
		(port_s (coerce port 'string))
		(temp (check-port port))
		(port_i (parse-integer port_s))
		(my_list0 (append lista (list port_i)))
		(my_list1 (append my_list0 '(NIL))))
	   (check-port port)
	   (parse-query my_list1 (cdr rest))))
	((present tail #\#)
	 (let* ((port (parse-to tail #\#))      
		(rest (parse-from tail #\#))
		(port_s (coerce port 'string))
		(temp (check-port port))
		(port_i (parse-integer port_s))
		(my_list (append lista (list port_i)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL))))
	   (check-port port)
	   (parse-fragment my_list2 (cdr rest))))
	(T
	 (let* ((port_s (coerce tail 'string))
		(temp (check-port tail))
		(port_i (parse-integer port_s))
		(my_list0 (append lista (list port_i)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL))))
	   (check-port tail)
	   (all-for-one my_list3)))))

(defun parse-path (lista tail &optional zos)
  (cond ((present tail #\?)
	 (let* ((path (parse-to tail #\?))      
		(rest (parse-from tail #\?))
		(path_s (make-path path))
		(my_list (append lista (list path_s))))
	   (cond ((null zos) (check-path path))
		 (T
		  (cond ((equal (car path) #\/) (check-path-zos (cdr path)))
			(T (check-path-zos path)))))
	   (parse-query my_list (cdr rest))))
	((present tail #\#)
	 (let* ((path (parse-to tail #\#))      
		(rest (parse-from tail #\#))
		(path_s (make-path path))
		(my_list0 (append lista (list path_s)))
		(my_list1 (append my_list0 '(NIL))))
	   (cond ((null zos) (check-path path))
		 (T
		  (cond ((equal (car path) #\/) (check-path-zos (cdr path)))
			(T (check-path-zos path)))))
	   (parse-fragment my_list1 (cdr rest))))
	(T
	 (let* ((path_s (make-path tail))
		(my_list0 (append lista (list path_s)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL))))
	   (cond ((null zos) (check-path tail))
		 (T
		  (cond ((equal (car tail) #\/) (check-path-zos (cdr tail)))
			(T (check-path-zos tail)))))
	   (all-for-one my_list2)))))

(defun parse-query (lista tail)
  (cond ((present tail #\#)
	 (let* ((query (parse-to tail #\#))      
		(rest (parse-from tail #\#))
		(query_s (coerce query 'string))
		(my_list (append lista (list query_s))))
	   (check-query query)
	   (parse-fragment my_list (cdr rest))))
	(T
	 (let* ((path_s (coerce tail 'string))
		(my_list0 (append lista (list path_s)))
		(my_list1 (append my_list0 '(NIL))))
	   (check-query tail)
	   (all-for-one my_list1)))))

(defun parse-fragment (lista tail)
  (let* ((fragment_s (coerce tail 'string))
	 (my_list (append lista (list fragment_s))))
    (check-fragment tail)
    (all-for-one my_list)))

(defun all-for-one (lista)
  (make-uri :scheme (car lista)
	    :userinfo (car (cdr lista))
	    :host (car (cdr (cdr lista)))
	    :port (car (cdr (cdr (cdr lista))))
	    :path (car (cdr (cdr (cdr (cdr lista)))))
	    :query (car (cdr (cdr (cdr (cdr (cdr lista))))))
	    :fragment (car (cdr (cdr (cdr (cdr (cdr (cdr lista)))))))))


;;;; mail parsing functions

(defun parse-userinfo-mail (lista tail)
  (cond ((null tail)
	 (let* ((my_list0 (append lista '(NIL)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (all-for-one my_list5)))
	((equal (car tail) #\:) (parse-userinfo-mail lista (cdr tail)))
	((present tail #\@)
	 (let* ((userinfo (parse-to tail #\@))
		(rest (parse-from tail #\@))
		(userinfo_s (coerce userinfo 'string))
		(my_list (append lista (list userinfo_s))))
	   (check-userinfo userinfo)
	   (parse-host-mail my_list rest)))
	(T
	 (let* ((userinfo_s (coerce tail 'string))
		(my_list0 (append lista (list userinfo_s)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (check-userinfo tail)
	   (all-for-one my_list5)))))

(defun parse-host-mail (lista tail)
  (cond ((equal (car tail) #\@) (parse-host-mail lista (cdr tail)))
	(T
	 (let* ((host_s (coerce tail 'string))
		(my_list0 (append lista (list host_s)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL))))
	   (check-host-opt tail)
	   (all-for-one my_list4)))))


;;;; tel/fax parsing functions

(defun parse-userinfo-tel (lista tail)
  (cond ((null tail)
	 (let* ((my_list0 (append lista '(NIL)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (all-for-one my_list5)))
	((equal (car tail) #\:) (parse-userinfo-tel lista (cdr tail)))
	(T
	 (let* ((userinfo_s (coerce tail 'string))
		(my_list0 (append lista (list userinfo_s)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (check-userinfo tail)
	   (all-for-one my_list5)))))


;;;; news parsing functions

(defun parse-host-news (lista tail)
  (cond ((null tail)
	 (let* ((my_list0 (append lista '(NIL)))
		(my_list1 (append my_list0 '(NIL)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (all-for-one my_list5)))
	((equal (car tail) #\:) (parse-host-news lista (cdr tail)))
	(T
	 (let* ((host_s (coerce tail 'string))
		(my_list0 (append lista '(NIL)))
		(my_list1 (append my_list0 (list host_s)))
		(my_list2 (append my_list1 '(NIL)))
		(my_list3 (append my_list2 '(NIL)))
		(my_list4 (append my_list3 '(NIL)))
		(my_list5 (append my_list4 '(NIL))))
	   (check-host-opt tail)
	   (all-for-one my_list5)))))



;;;; checking functions

(defun check-scheme (lista)
  (cond ((null lista) (error "SCHEME vuoto"))
	(T (check-identificatori lista 'scheme))))

(defun check-userinfo (lista)
  (check-identificatori lista 'userinfo))

(defun check-host (lista)
  (cond ((null lista) (error "HOST vuoto"))
	((or (equal (car (last lista)) #\.)
	     (equal (car lista) #\.))
	 (error "HOST non valido"))
	(T (check-identificatori lista 'host))))

(defun check-port (lista)
  (cond ((null lista))
	((is-digit (car lista)) (check-port (cdr lista)))
	(T (error "PORT non valido"))))

(defun check-path (lista)
  (cond ((null lista))
	((and (not (equal (car lista) #\@))
	      (not (equal (car lista) #\:)) (check-path (cdr lista))))
	(T (error "PATH non valido"))))
	
(defun check-query (lista)
  (check-identificatori lista 'query))

(defun check-fragment (lista)
  (check-identificatori lista 'fragment))

(defun check-host-opt (lista)
  (cond ((null lista) T)
	((or (equal (car (last lista)) #\.)
	     (equal (car lista) #\.))
	 (error "HOST non valido"))
	(T (check-identificatori lista 'host))))

(defun check-path-zos (lista)
  (cond ((null lista) T)
	((present lista #\()
	 (let* ((id44 (parse-to lista #\())
		(rest (parse-from lista #\()))
	   (check-id44 id44)
	   (check-id8 rest)))
	(T (check-id44 lista))))

(defun check-id44 (lista)
  (cond ((null lista)
	 (error "PATH non valido"))
	((> (list-length lista) 44)
	 (error "PATH non valido"))
	((not (alpha-char-p (car lista)))
	 (error "PATH non valido"))
	((not (alphanumericp (car (last lista))))
	 (error "PATH non valido"))
	(T (is-id44-safe lista))))

(defun check-id8 (lista)
  (cond ((null lista) T)
	((not (alpha-char-p (car (cdr lista))))
	 (error "PATH non valido"))
	((> (list-length lista) 10)
	 (error "PATH non valido"))
	((not (equal (car (last lista)) #\)))
	 (error "PATH non valido"))
	(T (let* ((my_list0 (cdr lista))
		  (my_id8 (parse-to my_list0 #\))))
	     (is-id8-safe my_id8)))))


;;;; display function

(defun uri-display (uri)
  (format t "Scheme:     ~s~%" (uri-scheme uri))
  (format t "Userinfo:   ~s~%" (uri-userinfo uri))
  (format t "Host:       ~s~%" (uri-host uri))
  (format t "Port:       ~d~%" (uri-port uri))
  (format t "Path:       ~s~%" (uri-path uri))
  (format t "Query:      ~s~%" (uri-query uri))
  (format t "Fragment:   ~s~%" (uri-fragment uri)))



;;;; utility functions

(defun parse-to (lista sym)
  (cond ((null lista) (error "'~a' non presente nella stringa" sym))
        ((equal (car lista) sym) NIL)
        (T (append (list (car lista)) (parse-to (cdr lista) sym)))))

(defun parse-from (lista sym)
  (cond ((null lista) (error "'~a' non presente nella stringa" sym))
	((equal (car lista) sym) lista)
	(T (parse-from (cdr lista) sym))))

(defun present (lista sym)
  (cond ((null lista) NIL)
	((equal (car lista) sym) T)
	(T (present (cdr lista) sym))))

(defun make-path (path_list)
  (cond ((null path_list) NIL)
	(T (coerce path_list 'string))))

(defun check-identificatori (lista section)
  (cond ((null lista))
	((is-identificatore (car lista))
	 (check-identificatori (cdr lista) section))
	(T (error "~s non valido" section))))

(defun is-identificatore (x)
  (cond ((and (not (equal x #\/))
	      (not (equal x #\?))
	      (not (equal x #\#))
	      (not (equal x #\@))
	      (not (equal x #\:)))
	 T)
	(T NIL)))

(defun is-digit (x)
  (cond ((or (equal x #\0)
	     (equal x #\1)
	     (equal x #\2)
	     (equal x #\3)
	     (equal x #\4)
	     (equal x #\5)
	     (equal x #\6)
	     (equal x #\7)
	     (equal x #\8)
	     (equal x #\9))
	 T)
	(T NIL)))

(defun is-id44-safe (lista)
  (cond ((null lista) T)
	((alphanumericp (car lista)) (is-id44-safe (cdr lista)))
	((equal (car lista) #\.) (is-id44-safe (cdr lista)))
	(T (error "PATH non valido"))))

(defun is-id8-safe (lista)
  (cond ((null lista) T)
	((alphanumericp (car lista)) (is-id8-safe (cdr lista)))
	(T (error "PATH non valido"))))



